= Implementing the API Gateway pattern with GraphQL
Vladimir Dejanovic <https://twitter.com/vladimird_42[@vladimird_42]>; Thomas Segismont <https://twitter.com/tsegismont[@tsegismont]>
:toc: left
:toclevels: 3
:source-highlighter: rouge

== Introduction

=== Microservices architecture

In a https://microservices.io/patterns/microservices.html[microservices architecture], several loosely coupled, independently deployable services comprise a large software application.

This type of design can provide quite a few benefits, including:

* ability to release more often and more reliably
* codebases easier to reason about
* independence to a particular technology

For example, an online store application could be composed of, among others, an inventory and a rating service:

[graphviz, microservices-architecture, svg]
.Online store application, microservices architecture
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> inventory
    client -> rating
    inventory -> inventorydb
    rating -> ratingdb
}
----

=== The API Gateway pattern

The client side of the application may have to contact several services to display a single screen or page.
For instance, to display a product details page, it needs product info from the inventory service and customer reviews from the rating service.

But each network communication comes with a cost.
This applies to desktop browsers with DSL or fiber links, but the impact is particularly significant on mobile networks.

This is one important reason why the _API Gateway_ pattern has emerged.
In practice, the client communicates with a single service, the gateway, which communicates with the backend services:

[graphviz, api-gateway-pattern, svg]
.API Gateway pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    gateway [label="API Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    gatewaydb [label="Gateway DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> gateway
    gateway -> gatewaydb
    gateway -> rating
    gateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = same; gateway; gatewaydb;}
}
----

[NOTE]
====
The API Gateway does not eliminate the coordination required to make sense of the backend data.
In fact, it adds a new network hop in the the sequence of service calls.

But it moves most of the interactions inside the datacenter, where network latencies are considerably better.
====

Very often, the API Gateway provides cross-cutting concerns like security.
For example, it could generate a token after authenticating the client and communicate it to the backend services as a proof of identity.

It may also provide its own features, if they are only relevant to the frontend.
An e-commerce application, for instance, could manage customers' shopping carts at the API Gateway level.

From a performance standpoint, an event-driven implementation would give better results under load.
Indeed, the API Gateway's workload is dominated by I/O, so having threads blocked waiting is not an optimal usage of resources.

=== Serving many clients

A lot of applications nowadays must be available from a wide range of clients: browsers, smartphones, tablets, wearables... etc.
These clients all have different capabilities in terms of display and networking.

Let's consider the product details use case.
For a desktop user, it makes sense to show:

* the product info (inventory service)
* the average rating (rating service)
* users' reviews (rating service)

However, in a smartphone app the reviews would probably be accessible in a separate view because of the screen size and shape.

But if the mobile developer uses the same endpoint as the web developer, the API Gateway wastes:

* time (_latency_) waiting for rating service responses, and
* bandwith sending a lot of unnecessary data.

To overcome this problem, it is possible to create a backend specific to each type of frontend.

[graphviz,backend-for-frontends,svg]
.Backend for Frontends pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    webclient [label="Web Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    mobileclient [label="Mobile Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    webgateway [label="Web Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    mobilegateway [label="Mobile Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    webclient -> webgateway
    mobileclient -> mobilegateway
    webgateway -> rating
    webgateway -> inventory
    mobilegateway -> rating
    mobilegateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = clients; mobileclient; webclient;}
    {rank = gateways; mobilegateway; webgateway;}
}
----

Nevertheless, this design, also known as the _Backend for Frontends_ pattern, has a few drawbacks:

* each specific API Gateway is another component to maintain
* a lot of code is duplicated
* each new feature has to be supported in all gateways before all clients can start using it

=== GraphQL in a nutshell

==== What it is

https://graphql.org/[GraphQL] is a query and schema definition language for your backend services.

It allows backend developers to describe the data in a language-agnostic fashion:

[source,graphql]
.GraphQL Schema file
----
type Genre {
  id: Int!
  name: String!
}

type Album {
  id: Int!
  name: String!
  genre: Genre!
  artist: String!
  reviews: [Review!]
}

type Review {
  name: String!
  rating: Int!
  comment: String
}

type Query {
  albums(genre: Int): [Album!]
}

schema {
  query: Query
}
----

And then frontend developers to request exactly the information they need:

[source,graphql]
.GraphQL query
----
query ($id: Int!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

Which, given an `id` variable, would result in:

[source,json]
.GraphQL results
----
{
  "album": {
    "name": "Revolver",
    "genre": {
      "name": "Pop"
    },
    "artist": "The Beatles"
  }
}
----

While the https://graphql.github.io/graphql-spec/[GraphQL specification] does not prescribe any transport, in practice it's often used over HTTP and Websockets.

TIP: You will find a GraphQL schema definition and query authoring introduction on https://graphql.org/learn/.

==== How it works

When a GraphQL server runtime starts, it:

. parses the schema file to discover types and fields
. binds each field to data fetching functions

[graphviz,graphql-server-runtime,svg]
.GraphQL server runtime creation
----
strict digraph {
    splines="line";
    schema [label="Types and Fields" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    fetchers [label="Data Fetchers" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    runtime [label="GraphQL Runtime" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    schema -> runtime
    fetchers -> runtime
}
----

Then when a request is received, it:

. validates the query
. invokes each data fetching function needed to produce the result
. sends the result to the client

[graphviz,graphql-query-execution,svg]
.GraphQL query execution phases
----
strict digraph {
    rankdir=LR;
    splines="line";
    validation [label="Validation" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    execution [label="Execution" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    result [label="Result" shape="ellipse" color="#585858" style="filled" fillcolor="#782b90" fontcolor="white"]
    validation -> execution
    execution -> result
}
----

==== API Gateway engine

GraphQL becomes more and more popular, including as a replacement for _RESTful_ or HTTP/JSON APis.

But it particularly shines when building API Gateways.
Why?
Let's consider the product details use case again.

When the desktop client sends a request to the GraphQL runtime, it will ask for product info as well as users' review.
And the runtime will execute the corresponding data fetchers:

[source,graphql]
.Desktop client query
----
query ($id: Int!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
    reviews {
      name
      comment
      rating
    }
  }
}
----

However, the smartphone client will only ask for the product info:

[source,graphql]
.Smartphone client query
----
query ($id: Int!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

And the runtime will **NOT** execute the data fetchers for customers' reviews and, obviously, will not send the unnecessary data.

== The MusicStore Application

The _MusicStore_ is an online music shop.
You can browse its catalog by genre, read customer reviews, see the list of tracks.
When logged-in, you may add albums to your cart, manage your cart items or post your own reviews.

Technically, it is comprised of the following components:

* the <<Web Client>>
* the API Gateway which:
** serves the static content
** runs the GraphQL runtime
** authenticates the customers
** records cart items
* the <<Inventory Service>>
* the <<Rating Service>>

[graphviz,musicstore-app,svg]
.The _MusicStore_ application
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Web Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    gateway [label="API Gateway" shape="polygon" color="#782b90" style="rounded" fontcolor="#782b90" fontsize="25" penwidth="2" height=".6"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    gatewaydb [label="MusicStore DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> gateway
    gateway -> gatewaydb
    gateway -> rating
    gateway -> inventory
    {rank = same; gateway; gatewaydb;}
}
----

You will build the API Gateway for this microservices-based application.

NOTE: In a real-world application, the static content would often be served from a separate component.

=== Web Client

A _Single Page Application_ implemented with https://vuejs.org/[Vue.js] and https://www.apollographql.com/docs/react/[Apollo client].

=== Inventory Service

The _Inventory Service_ exposes product data over HTTP in JSON format:

* genres
* albums (name, artist, genre, ...etc)
* tracks

For the sake of simplicity, inventory data is loaded on startup from text files and stored into memory.

=== Rating Service

The _Rating Service_ receives customers' reviews on albums:

* customer name
* rating
* comment

It exposes this data over HTTP in JSON format.
It can also compute an average rating for each album.

Again, for simplicity, reviews are stored only in memory.

== Getting started

=== Prerequisites

==== Java Development Kit

JDK 8 or later must be installed on our machine.
If you don't have it already, you can get one from:

* https://adoptopenjdk.net, or
* https://www.oracle.com/technetwork/java/javase/downloads/index.html

You can use either OpenJDK or Oracle JDK.

==== Maven

Download Apache Maven from https://maven.apache.org/download.cgi.

Extract the archive contents to a directory of your choice and add it to the `PATH`.

==== IDE

It is recommended to use an IDE. It does not matter if it's IntelliJ, Eclipse or Netbeans.

If you don’t have an IDE, follow these instructions to get started with Eclipse:

* browse to the https://www.eclipse.org/downloads/packages/[Eclipse downloads page]
* select the _Eclipse IDE for Java Developers_ package and download it
* extract the archive contents to a directory of your choice
* in the destination directory, execute the Eclipse binary
* create a workspace

==== Postgres database

IMPORTANT: The Postgres database is only required to complete the last step or to run the full solution.
If you cannot get it to work on your machine, you can still complete all the other steps.

If you have Docker running on your machine, you can start the Postgres database in a container:

[source,shell]
.Starting a Postgres Database with Docker
----
docker run -p 5432:5432 -e POSTGRES_USER=musicstore -e POSTGRES_PASSWORD=musicstore -d postgres
----

TIP: Linux and Mac users can simply execute the `run-postgres.sh` script after having imported the code in the next step.

Otherwise:

* download Postgres from https://www.postgresql.org/download/ and follow the instructions for your machine type
* create a `musicstore` database
* create a `musicstore` user with password `musicstore`
* grant the `musicstore` user with the permission to create tables on the the `musicstore` database

As a _superuser_ you could run these queries:

[source,sql]
----
CREATE DATABASE musicstore;
CREATE USER musicstore WITH ENCRYPTED PASSWORD 'musicstore';
GRANT ALL PRIVILEGES ON DATABASE musicstore TO musicstore;
----

=== Importing the code

The project code is hosted on GitHub.
Open a terminal in the directory of your choice and type:

[source,shell]
----
git clone https://github.com/tsegismont/graphql-api-gateway-workshop.git
----

Alternatively, you may download the https://codeload.github.com/tsegismont/graphql-api-gateway-workshop/zip/master[project archive] from GitHub and extract the content.

Inside the project directory, run Maven to build the project:

[source,shell]
----
mvn install
----

Now open the IDE and import the project.

In Eclipse:

* click on _File_ > _Import_
* select _Maven_ > _Existing Maven Projects_
* in _Root Directory_, type the project directory path or select it with the _Browse..._ button
* make sure the root project and all sub-projects checkboxes are ticked and click _Finish_

In IntelliJ:

* click on _File_ > _New_ > _Project from Existing Sources_
* select the `pom.xml` file at the root of the project directory path and click _OK_
* click _Next_ on the following wizard panels and then _Finish_

=== Running backend services

IMPORTANT: Make sure you have built the project beforehand and started the Postgres database.

==== Inventory

Open a terminal at the root of the project directory and type:

[source,shell]
----
cd inventory
./run.sh
----

On Windows, open the file explorer in the `inventory` directory and execute `run.bat`.

If the service starts correctly, you should see a line similar to this on the console:

----
[2019-11-02 21:05:24] [INFO   ] Succeeded in deploying verticle
----

==== Rating

Open a terminal at the root of the project directory and type:

[source,shell]
----
cd rating
./run.sh
----

On Windows, open the file explorer in the `rating` directory and execute `run.bat`.

If the service starts correctly, you should see a line similar to this on the console:

----
[2019-11-02 21:05:24] [INFO   ] Succeeded in deploying verticle
----

== Let's code!

=== Building blocks

==== GraphQL-Java

The https://www.graphql-java.com/[GraphQL-Java] library is the Java implementation of the GraphQL specification.

To configure it, you must provide at least:

* a GraphQL schema, either from a definition file or built programmatically
* data fetchers functions for schema types and fields (_runtime wiring_)

A GraphQL-Java data fetcher must implement the `graphql.schema.DataFetcher` interface.
In practice, it must have a `get` method that takes a `graphql.schema.DataFetchingEnvironment` argument and returns a result:

[source,java]
.DataFetcher interface
----
public interface DataFetcher<T> {
    T get(DataFetchingEnvironment environment) throws Exception;
}
----

The result can be a `CompletionStage` if it is provided asynchronously.

The _environment_ argument gives information about the current position in the graph: source type, arguments, fields to be fetched... etc

The GraphQL-Java runtime job is to execute queries and it does not provide any transport implementation.

==== Eclipse Vert.x

https://vertx.io[Vert.x] is a toolkit to write asynchronous and reactive applications on the JVM.

It implements the reactor pattern and uses _Netty_ for the networking layer.
It is similar to _Node.js_ but it is capable of scaling across CPU cores instead of using a single thread.

Vert.x does not mandate any programming model but the easiest way to get started is to create a _verticle_.

A verticle is an entry-point class with a _start_ method:

[source,java]
.Vert.x verticle
----
public class MyVerticle extends AbstractVerticle {

 // Called when verticle is deployed
 public void start() {
 }

 // Optional - called when verticle is undeployed
 public void stop() {
 }

}
----

The core library provides low-level abstractions to start HTTP servers, work with the filesystem, ...etc.

https://vertx.io/docs/vertx-web-graphql/java/[Vert.x Web GraphQL] integrates the GraphQL-Java library so that queries and results can be sent over HTTP and Websockets.

==== RxJava

Quotinq the https://github.com/ReactiveX/RxJava[RxJava] project website:

[quote, RxJava project]
RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.

When working with asynchronous APIs, the code can quickly become difficult to understand if you need to execute several sequential operations.
It's even worse when composing results of concurrent operations.

This issue is widely known as callback-hell and RxJava provides operators to deal with it.

NOTE: `CompletableFuture` / `CompletionStage` introduced in JDK 8 helps a lot with asynchronous composition.
But RxJava comes with a broader range of operators and is also able to deal with asynchronous data flows.

Let's take a couple of examples:

[source,java]
.Sequential composition: async Postgres query execution and transformation of row results into a Java object
----
public Single<Cart> findCart(String username) {
  return pool.rxPreparedQuery(FIND_CART, Tuple.of(username))
    .flatMapObservable(Observable::fromIterable)
    .map(CartRepository::rowToCartItem)
    .collectInto(new Cart(), Cart::add);
}
----

[source,java]
.Concurrent composition: combining results of async web client requests into a single Java object
----
Single<Album> inventoryData = albumsRepository.findById(id, true);
Single<RatingInfo> ratingData = ratingRepository.findRatingAndReviewsByAlbum(id);
return inventoryData.zipWith(ratingData, (a, r) -> {
  a.setRating(r.getRating());
  a.setReviews(r.getReviews());
  return a;
});
----

By default, Vert.x uses a callback style but it also has an https://vertx.io/docs/vertx-rx/java2/[Rxified API].

=== Steps

This lab is divided into several steps incrementally building the API Gateway for the _MusicStore_ application.

Each step can be run separately.
To do so, open a terminal in the step directory and type:

[source,shell]
----
mvn vertx:run
----

Then start coding.
The step projects all use the _Vert.x Maven plugin_ which automatically redeploys the code when a file changes.

On Windows, open the file explorer in the step directory and execute `run.bat`.

The files to edit are either in the `src/main/java` or the `src/main/resources` directory.

Each step has its solution in the `src/solution` directory.
You may run it with:

[source,shell]
----
mvn clean package -Psolution
java -jar target/step-0.jar -Dvertxweb.environment=dev
----

On Windows, open the file explorer in the step directory and execute `run-solution.bat`.

IMPORTANT: To avoid port conflicts, don't forget to close the server before you start working on the next step.

A complete solution can be found in the `gateway` directory.

==== Step 0: Vert.x Web Router

The Vert.x core library, as explained above, has very low-level abstractions for HTTP servers.

https://vertx.io/docs/vertx-web/java/[Vert.x Web] is a module that builds on top of Vert.x core and provides features commonly found in a web server:
static file serving, session management, authentication and authorization and much more.

The basic Vert.x Web construct is the _Router_.
It allows to create _routes_ matching requests by path or HTTP method and delegates execution to _handlers_.

[source,java]
----
Router router = Router.router(vertx); // <1>

router.get().handler(StaticHandler.create()); // <2>

router.route().failureHandler(ErrorHandler.create()); // <3>
----
<1> Router creation for a given Vert.x instance
<2> Any `GET` request should be handled by the https://vertx.io/docs/vertx-web/java/#_serving_static_resources[`StaticHandler`] for static file serving
<3> If anything gets wrong for any type of request, invoke the https://vertx.io/docs/vertx-web/java/#_error_handling[`ErrorHandler`].

===== Exercise

In the IDE, open the `steps/step-0/src/main/java/workshop/gateway/Step0Server.java` file.

Implement the TODOs found in the `createRouter` method.

===== Observations

Browse to http://localhost:8080.

The browser should display the _MusicStore_ welcome page.

NOTE: The error message _Failed to load data..._ is expected as we haven't implemented the GraphQL runtime yet.

==== Step 1: The GraphQL-Java runtime

Now that we have a web server, let's configure the GraphQL runtime.

Firstly, we need a GraphQL schema file.

The schema must contain at least a root `Query` type and its fields are the entry points to the graph:

[source,graphql]
----
type Genre {
  id: Int! # <3>
  name: String! # <4>
  image: String
}

type Query { # <1>
  genres: [Genre!] # <2>
}

schema {
  query: Query
}
----
<1> root query type
<2> the `genres` field returns an array of `Genre` objects
<3> `Integer` is one of the built-in scalar types
<4> fields are nullable unless marked by `!`

Secondly, we must configure the runtime to define data fetchers.
In GraphQL-Java this is called _runtime wiring_:

[source,java]
----
protected RuntimeWiring runtimeWiring() {
  return RuntimeWiring.newRuntimeWiring()
    .type("Query", this::query) // <1>
    .build();
}

private TypeRuntimeWiring.Builder query(TypeRuntimeWiring.Builder builder) {
  return builder
    .dataFetcher("genres", new GenresDataFetcher(genresRepository)) // <2>
    ;
}
----
<1> Runtime wiring configuration of the root `Query` type provided by the `query` method
<2> Define the `GenresDataFetcher` object for the `genres` field of the `Query` type

NOTE: The `workshop.gateway.WorkshopVerticle` class exposes a few repositories that implement the data access layer to the inventory service, the rating service, as well as the Postgres database.

The `GenresDataFetcher` extends `workshop.gateway.RxDataFetcher`, which is an adpater for the RxJava `Single` type that GraphQL-Java does not understand:

[source,java]
----
include::common/src/main/java/workshop/gateway/RxDataFetcher.java[]
----

Lastly, the Vert.x Web router must declare a route for `/graphql` requests and set the `GraphQLHandler`:

[source,java]
----
GraphQL graphQL = setupGraphQLJava("musicstore.graphql");
router.route("/graphql").handler(GraphQLHandler.create(graphQL));
----

===== Exercise

In the IDE, open the `steps/step-1/src/main/resources/musicstore.graphql` file.

Implement the TODOs found in the `Genre` and `Query` types.

Open the `steps/step-1/src/main/java/workshop/gateway/Step1Server.java` file.

Implement the TODOs found in the `createRouter` and `query` methods.

Open the `steps/step-1/src/main/java/workshop/gateway/GenresDataFetcher.java` file.

Implement the TODOs found in the `rxGet` method.

===== Observations

Browse to http://localhost:8080.

The browser should display the list of genres available in the _MusicStore_.

Browse to http://localhost:8080/graphiql/.

GraphiQL is an IDE to author GraphQL queries.

In the query panel, type the following query and execute it:

[source,graphql]
----
query {
  genres {
    id
  }
}
----

In the results panel you should see:

[source,json]
----
{
  "data": {
    "genres": [
      {
        "id": 1
      },
      {
        "id": 2
      },
      {
        "id": 3
      }
    ]
  }
}
----

Modify the query to fetch other fields (`name` or `image`).
The result should have exactly the information you required, no more no less.

TIP: In the top right corner of the web page, click the `Docks` link.
GraphiQL will open the schema explorer.
This can be useful when working with a schema that you do not own.

==== Step 2: Fields with arguments

GraphQL types can have fields taking arguments.
This can be useful for filtering or paging results.

[source,graphql]
----
type Query {
  genres: [Genre!]
  albums(genre: Int): [Album!] # <1>
}
----
<1> the `albums` field of the root `Query` type takes a `genre` argument of type `Int`

In the data fetcher implementation, the argument value is retrieved from the `DataFetchingEnvironment`:

[source,java]
----
Integer genre = env.getArgument("genre");
----

===== Exercise

In the IDE, open the `steps/step-2/src/main/resources/musicstore.graphql` file.

Implement the TODOs found in the `Album` and `Query` types.

Open the `steps/step-2/src/main/java/workshop/gateway/Step2Server.java` file.

Implement the TODO found in the `query` method.

Open the `steps/step-2/src/main/java/workshop/gateway/AlbumsDataFetcher.java` file.

Implement the TODO found in the `rxGet` method.

===== Observations

Browse to http://localhost:8080/graphiql/.

In the query panel, type the following query and execute it:

[source,graphql]
----
query($genre:Int) {
  albums(genre: $genre)  {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

In the results panel you should see all albums because we haven't provided any value for this nullable argument.

Then open the query variables panel and type:

[source,json]
----
{"genre": 2}
----

Execute the query again.
Now in the results panel you should see:

[source,json]
----
{
  "data": {
    "albums": [
      {
        "id": 9,
        "name": "Dark Side Of The Moon",
        "genre": {
          "name": "Rock"
        },
        "artist": "Pink Floyd"
      },
      {
        "id": 10,
        "name": "Appetite For Destruction",
        "genre": {
          "name": "Rock"
        },
        "artist": "Guns N' Roses"
      },
      {
        "id": 11,
        "name": "Back In Black",
        "genre": {
          "name": "Rock"
        },
        "artist": "AC/DC"
      },
      {
        "id": 12,
        "name": "Master Of Puppets",
        "genre": {
          "name": "Rock"
        },
        "artist": "Metallica"
      }
    ]
  }
}
----

==== Step 3: Fetching data efficiently

In this step, the schema has been modified in order to get all albums details in a single query:

[source,graphql]
----
include::steps/step-3/src/main/resources/musicstore.graphql[]
----

Then of course the corresponding data fetcher has been defined in runtime wiring:

[source,java]
----
include::steps/step-3/src/main/java/workshop/gateway/Step3Server.java[]
----

In the data fetcher implementation, two concurrent requests are sent to the inventory and rating services and results get merged, thanks to RxJava's `zip` operator:

[source,java]
----
Single<Album> inventoryData = albumsRepository.findById(id, true); // <1>
Single<RatingInfo> ratingData = ratingRepository.findRatingAndReviewsByAlbum(id); // <2>
return inventoryData.zipWith(ratingData, (a, r) -> { // <3>
  a.setRating(r.getRating());
  a.setReviews(r.getReviews());
  return a;
});
----
<1> Load album data (including tracks) from inventory service
<2> Load rating and reviews from rating service
<3> Merge rating data into one `Album` object

Why fetching all this data at once?

Because if a user sends a query for a specific album, chances are high the full set of fields will be needed.

Consequently, it is more efficient to:

. retrieve album data with tracks included in a single backend request
. retrieve rating data concurrently

===== Exercise

In the IDE, open the `steps/step-3/src/main/java/workshop/gateway/AlbumDataFetcher.java` file.

Implement the TODOs found in the `rxGet` method.

===== Observations

Browse to http://localhost:8080/graphiql/.

In the query panel, type the following query and execute it:

[source,graphql]
----
{
  album(id: 8) {
    name
    artist
    rating
    reviews {
      name
    }
    tracks {
      number
      name
    }
  }
}
----

In the results panel you should see:

[source,json]
----
{
  "data": {
    "album": {
      "name": "Thriller",
      "artist": "Michael Jackson",
      "rating": 0,
      "reviews": [],
      "tracks": [
        {
          "number": 1,
          "name": "Wanna Be Startin' Somethin'"
        },
        {
          "number": 2,
          "name": "Baby Be Mine"
        },
        {
          "number": 3,
          "name": "The Girl Is Mine"
        },
        {
          "number": 4,
          "name": "Thriller"
        },
        {
          "number": 5,
          "name": "Beat It"
        },
        {
          "number": 6,
          "name": "Billie Jean"
        },
        {
          "number": 7,
          "name": "Human Nature"
        },
        {
          "number": 8,
          "name": "P.Y.T. (Pretty Young Thing)"
        },
        {
          "number": 9,
          "name": "The Lady in My Life"
        }
      ]
    }
  }
}
----

Of course rating data is not available yet.
But if you open the inventory service console, you will see a single request for each `album` GraphQL query:

----
[2019-11-03 10:12:23] [INFO   ] GET /album/8?withTracks= 200 481 - 1 ms
----

==== Step 4: On demand data fetching

In the previous step, we made tracks, rating and reviews data available when users execute the `album` query.

But what about a user who would like to get some or all of this data from another entry point in the graph?

For example, if you display a list of albums of a single genre, you might want to present each album's rating on the web page.

To do so, the runtime wiring must define how these `Album` fields can be fetched:

[source,java]
----
protected RuntimeWiring runtimeWiring() {
  return RuntimeWiring.newRuntimeWiring()
    .type("Query", this::query)
    .type("Album", this::album) // <1>
    .build();
}

private TypeRuntimeWiring.Builder album(TypeRuntimeWiring.Builder builder) { // <2>
  return builder
    .dataFetcher("tracks", new AlbumTracksDataFetcher(tracksRepository))
    .dataFetcher("rating", new AlbumRatingDataFetcher(ratingRepository))
    .dataFetcher("reviews", new AlbumReviewsDataFetcher(ratingRepository))
    ;
}
----
<1> Define `Album` runtime wiring in the `album` method
<2> Data fetchers definitions for fields that are not always present in the `Album` object

Let's take a look at the data fetcher implementation:

[source,java]
----
include::steps/step-4/src/main/java/workshop/gateway/AlbumRatingDataFetcher.java[]
----

IMPORTANT: Notice that the `rating` field is loaded only if not already present.
Indeed, without this protection, we would send two requests to the rating service when we execute the `album` query.

===== Exercise

In the IDE, open the `steps/step-4/src/main/java/workshop/gateway/Step4Server.java` file.

Implement the TODO found in the `runtimeWiring` method.

Open the `steps/step-4/src/main/java/workshop/gateway/AlbumTracksDataFetcher.java` file.

Implement the TODOs found in the `rxGet` method.

===== Observations

Browse to http://localhost:8080/graphiql/.

In the query panel, type the following query and execute it:

[source,graphql]
----
{
  albums(genre: 2) {
    name
    tracks {
      name
    }
  }
}
----

In the results panel you should see:

[source,json]
----
{
  "data": {
    "albums": [
      {
        "name": "Dark Side Of The Moon",
        "tracks": [
          {
            "name": "Speak To Me"
          },
          {
            "name": "Breathe (In The Air)"
          },
          {
            "name": "On The Run"
          },
          {
            "name": "Time"
          },
          {
            "name": "The Great Gig In The Sky"
          },
          {
            "name": "Money"
          },
          {
            "name": "Us And Them"
          },
          {
            "name": "Any Colour You Like"
          },
          {
            "name": "Brain Damage"
          },
          {
            "name": "Eclipse"
          }
        ]
      },
      {
        "name": "Appetite For Destruction",
        "tracks": [
          {
            "name": "Welcome To The Jungle"
          },
          {
            "name": "It's So Easy"
          },
          {
            "name": "Nightrain"
          },
          {
            "name": "Out Ta Get Me"
          },
          {
            "name": "Mr. Brownstone"
          },
          {
            "name": "Paradise City"
          },
          {
            "name": "My Michelle"
          },
          {
            "name": "Think About You"
          },
          {
            "name": "Sweet Child O' Mine"
          },
          {
            "name": "You're Crazy"
          },
          {
            "name": "Anything Goes"
          },
          {
            "name": "Rocket Queen"
          }
        ]
      },
      {
        "name": "Back In Black",
        "tracks": [
          {
            "name": "Hells Bells"
          },
          {
            "name": "Shoot to Thrill"
          },
          {
            "name": "What Do You Do for Money Honey"
          },
          {
            "name": "Givin the Dog a Bone"
          },
          {
            "name": "Let Me Put My Love Into You"
          },
          {
            "name": "Back In Black"
          },
          {
            "name": "You Shook Me All Night Long"
          },
          {
            "name": "Have a Drink on Me"
          },
          {
            "name": "Shake a Leg"
          },
          {
            "name": "Rock and Roll Ain't Noise Pollution"
          }
        ]
      },
      {
        "name": "Master Of Puppets",
        "tracks": [
          {
            "name": "Battery"
          },
          {
            "name": "Master Of Puppets"
          },
          {
            "name": "The Thing That Should Not Be"
          },
          {
            "name": "Welcome Home (Sanitarium)"
          },
          {
            "name": "Disposable Heroes"
          },
          {
            "name": "Leper Messiah"
          },
          {
            "name": "Orion"
          },
          {
            "name": "Damage Inc."
          }
        ]
      }
    ]
  }
}
----

Then type and execute this `albumQuery`:

[source,graphql]
----
{
  album(id: 1) {
    tracks {
      number
      name
    }
  }
}
----

In the inventory service console, you should a single request logged:

----
[2019-11-03 10:12:23] [INFO   ] GET /album/1?withTracks= 200 528 - 1 ms
----

Browse to http://localhost:8080 and explore the _MusicStore_ catalog.

==== Step 5: Authentication

It is good if an online store lets you browse its product catalog.
But isn't it better if customers can buy items and write reviews?

Before doing so, a critical piece is missing on the API Gateway: authentication.

In the real-world, authentication for microservices-based applications is often delegated to a separated component.

But here we will simply focus on how:

. security can be added to the Vert.x Web server
. user info can be retrieved from data fetchers

Vert.x Web provides security handlers that can be added to the router to implement different authentication mechanisms.

Let's say we want to authenticate users with a form, storing credentials in an https://httpd.apache.org/docs/current/en/programs/htpasswd.html[`htpassword`] file.
When authenticating, the server should store user info in the web session.
If the user logs out, the session data must be destroyed eagerly instead of waiting for session timeout.

First, an auth provider must be created:

[source,java]
----
HtpasswdAuthOptions authOptions = new HtpasswdAuthOptions()
  .setHtpasswdFile("passwordfile")
  .setPlainTextEnabled(true);
HtpasswdAuth authProvider = HtpasswdAuth.create(vertx, authOptions);
----

WARNING: Do not enable plaintext `htpassword` files in production!

Then a session handler added to the router:

[source,java]
----
SessionHandler sessionHandler = SessionHandler.create(LocalSessionStore.create(vertx)).setAuthProvider(authProvider);
router.route().handler(sessionHandler);
----

The session handler will inspect all incoming requests to determine if a session cookie is present and add user info the the `RoutingContext`.

HTTP `POST` requests to the `/login.html` path shall be handled by a form login handler:

[source,java]
----
FormLoginHandler formLoginHandler = FormLoginHandler.create(authProvider).setDirectLoggedInOKURL("/");
router.post("/login.html").handler(formLoginHandler);
----

Lastly, HTTP `GET` requests to the `/logout` path should trigger session data removal:

[source,java]
----
router.get("/logout").handler(rc -> {
  rc.clearUser();
  rc.session().destroy();
  rc.response().setStatusCode(307).putHeader(HttpHeaders.LOCATION, "/").end();
});
----

[NOTICE]
====
This is the first time we implement a Vert.x Web handler.

In a nutshell, a Vert.x Web handler is an operation that takes a single `RoutingContext` argument and interact with the HTTP server request and response.

A handler can terminate the routing process by replying to the response or hand-over to the next handler by calling `RoutingContext#next()`.
====

Authentication is now set up, but what about retrieving user info in data fetchers?

The `DataFetchingEnvironment` provides a context object.
Since the GraphQL runtime is independent of any transport, the content of this object depends on the GraphQL-Java integration.

Vert.x Web GraphQL, by default, puts the `RoutingContext` instance in the GraphQL context.
Consequently it allows you to retrieve the user info:

[source,java]
----
RoutingContext routingContext = env.getContext();
User user = routingContext.user();
return user!=null ? user.principal().getString("username"):null;
----

===== Exercise

In the IDE, open the `steps/step-5/src/main/java/workshop/gateway/Step5Server.java` file.

Implement the TODOs found in the `createRouter` method.

Open the `steps/step-5/src/main/java/workshop/gateway/UserUtil.java` file.

Implement the TODOs found in the `currentUser` method.

===== Observations

Browse to http://localhost:8080 and click on the login menu button located at the top right.

You can either connect with username `vladimir` or `thomas`.
The password is the username.

Browse to http://localhost:8080/album/9.

The _Add to cart_ button should now be visibile as well as the review input section at the bottom of the page.

==== Step 6: Mutations

We have seen that a GraphQL schema must contain at least a root `Query`.

Another entry point to the graph is the `Mutation` type.

Mutations, in the schema file, look like their queries counterpart, except that:

* the different semantic is a signal for ther server runtime and client implementations that backend data is going to change
* they can take an `Input` argument

Here is how the schema is changed to support customer reviews:

[source,graphql]
----

input ReviewInput {
  rating: Int!
  comment: String
}

type ReviewResult {
  rating: Int!
  reviews: [Review!]!
}

type Mutation {
  addReview(albumId: Int!, review: ReviewInput): ReviewResult
}
----

On the server-side, GraphQL-Java executes queries and mutations differently:
while it does not invoke data fetchers for query fields in any particular order, those of mutations are, as per the specification, always invoked *serially* and *in the order defined by the schema*.

Otherwise mutation data fetchers are configured exactly in the same way:

[source,java]
----
protected RuntimeWiring runtimeWiring() {
  return RuntimeWiring.newRuntimeWiring()
    .type("Query", this::query)
    .type("Mutation", this::mutation)
    .type("Album", this::album)
    .build();
}

private TypeRuntimeWiring.Builder mutation(TypeRuntimeWiring.Builder builder) {
  return builder
    .dataFetcher("addReview", new AddReviewDataFetcher(ratingRepository))
    ;
}
----

In the data fetcher implementation, the input argument is retrieved from the `DataFetchingEnvironment`:

[source,java]
----
String currentUser = UserUtil.currentUser(env);
if (currentUser==null) {
  throw new NotLoggedInException();
}
Integer albumId = env.getArgument("albumId");
ReviewInput reviewInput = EnvironmentUtil.getInputArgument(env, "review", ReviewInput.class);
reviewInput.setName(currentUser);
return ratingRepository.addReview(albumId, reviewInput);
----

===== Exercise

In the IDE, open the `steps/step-6/src/main/resources/musicstore.graphql` file.

Implement the TODOs found in the `ReviewInput` input type.

Open the `steps/step-6/src/main/java/workshop/gateway/AddReviewDataFetcher.java` file.

Implement the TODOs found in the `rxGet` method.

===== Observations

Browse to http://localhost:8080 and click on the login menu button located at the top right.

You can either connect with username `vladimir` or `thomas`.
The password is the username.

Select an album and scroll down to the bottom of the page.
Add a review.

You should see the review result added below the form.

Then scroll up to the top and the average rating should have been updated.

Browse back to the genre page of this album.

The average rating of the album should be present.

Note that, when displaying the genre page, the rating service console shows that the API Gateway sent a request only for the average rating, not for the reviews:

----
[2019-11-05 10:58:22] [INFO   ] GET /album/12/rating 200 11 - 1 ms
----

==== Step 7: On demand data fetching in mutation results

IMPORTANT: You cannot complete this step if you haven't setup the Postgres Database successfully.

In the previous step, we added a `Mutation` type for customer reviews.
The `addReview` mutation returned a `ReviewResult` that had all the data loaded.

However, since mutation results behave the same as query results, we can also fetch data on demand.

Let's say we modify the schema to support adding and removing items from a shopping cart:

[source,graphql]
----
type CartItem {
  album: Album
  quantity: Int
}

type Cart {
  items: [CartItem!]
}

type Mutation {
  addToCart(albumId: Int!): Cart
  removeFromCart(albumId: Int!): Cart
  addReview(albumId: Int!, review: ReviewInput): ReviewResult
}
----

We must define a data fetcher for the `album` field of the `CartItem` type:

[source,java]
----
protected RuntimeWiring runtimeWiring() {
  return RuntimeWiring.newRuntimeWiring()
    .type("Query", this::query)
    .type("Mutation", this::mutation)
    .type("Album", this::album)
    .type("CartItem", this::cartItem)
    .build();
}


private TypeRuntimeWiring.Builder cartItem(TypeRuntimeWiring.Builder builder) {
   return builder
    .dataFetcher("album", new CartItemAlbumDataFetcher(albumsRepository))
    ;
}
----

In the data fetcher implementation, we should return the album data from the inventory service:

[source,java]
----
CartItem cartItem = env.getSource();
return albumsRepository.findById(cartItem.getAlbumId(), false);
----

NOTE: The `withTracks` param is set to false because it is unlikely that a page dealing with the shopping cart will need the tracks list.
It would still be available on demand though.

===== Exercise

In the IDE, open the `steps/step-7/src/main/resources/musicstore.graphql` file.

Implement the TODO found in the `CartItem` input type.

Open the `steps/step-7/src/main/java/workshop/gateway/Step7Server.java` file.

Implement the TODO found in the `cartItem` method.

Open the `steps/step-7/src/main/java/workshop/gateway/CartItemAlbumDataFetcher.java` file.

Implement the TODOs found in the `rxGet` method.

===== Observations

Browse to http://localhost:8080 and click on the login menu button located at the top right.

You can either connect with username `vladimir` or `thomas`.
The password is the username.

Select an album and click the _Add to cart_ button.

You should see a popup with the message `Done!`.

On the top right of the page, the cart icon should show a badge with the number of items in the cart.

Click on the cart icon.

In the cart page, add or remove items.
