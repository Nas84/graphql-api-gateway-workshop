= Implementing the API Gateway pattern with GraphQL
Vladimir Dejanovic <https://twitter.com/vladimird_42[@vladimird_42]>; Thomas Segismont <https://twitter.com/tsegismont[@tsegismont]>
:toc: left
:toclevels: 3
:source-highlighter: rouge

== Introduction

=== Microservices architecture

In a https://microservices.io/patterns/microservices.html[microservices architecture], several loosely coupled, independently deployable services comprise a large software application.

This type of design can provide quite a few benefits, including:

* ability to release more often and more reliably
* codebases easier to reason about
* independence to a particular technology

For example, an online store application could be composed of, among others, an inventory and a rating service:

[graphviz, microservices-architecture, svg]
.Online store application, microservices architecture
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> inventory
    client -> rating
    inventory -> inventorydb
    rating -> ratingdb
}
----

=== The API Gateway pattern

The client side of the application may have to contact several services to display a single screen or page.
For instance, to display a product details page, it needs product info from the inventory service and customer reviews from the rating service.

But each network communication comes with a cost.
This applies to desktop browsers with DSL or fiber links, but the impact is particularly significant on mobile networks.

This is one important reason why the _API Gateway_ pattern has emerged.
In practice, the client communicates with a single service, the gateway, which communicates with the backend services:

[graphviz, api-gateway-pattern, svg]
.API Gateway pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    gateway [label="API Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    gatewaydb [label="Gateway DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> gateway
    gateway -> gatewaydb
    gateway -> rating
    gateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = same; gateway; gatewaydb;}
}
----

[NOTE]
====
The API Gateway does not eliminate the coordination required to make sense of the backend data.
In fact, it adds a new network hop in the the sequence of service calls.

But it moves most of the interactions inside the datacenter, where network latencies are considerably better.
====

Very often, the API Gateway provides cross-cutting concerns like security.
For example, it could generate a token after authenticating the client and communicate it to the backend services as a proof of identity.

It may also provide its own features, if they are only relevant to the frontend.
An e-commerce application, for instance, could manage customers' shopping carts at the API Gateway level.

From a performance standpoint, an event-driven implementation would give better results under load.
Indeed, the API Gateway's workload is dominated by I/O, so having threads blocked waiting is not an optimal usage of resources.

=== Serving many clients

A lot of applications nowadays must be available from a wide range of clients: browsers, smartphones, tablets, wearables... etc.
These clients all have different capabilities in terms of display and networking.

Let's consider the product details use case.
For a desktop user, it makes sense to show:

* the product info (inventory service)
* the average rating (rating service)
* users' reviews (rating service)

However, in a smartphone app the reviews would probably be accessible in a separate view because of the screen size and shape.

But if the mobile developer uses the same endpoint as the web developer, the API Gateway wastes:

* time (_latency_) waiting for rating service responses, and
* bandwith sending a lot of unnecessary data.

To overcome this problem, it is possible to create a backend specific to each type of frontend.

[graphviz,backend-for-frontends,svg]
.Backend for Frontends pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    webclient [label="Web Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    mobileclient [label="Mobile Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    webgateway [label="Web Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    mobilegateway [label="Mobile Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    webclient -> webgateway
    mobileclient -> mobilegateway
    webgateway -> rating
    webgateway -> inventory
    mobilegateway -> rating
    mobilegateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = clients; mobileclient; webclient;}
    {rank = gateways; mobilegateway; webgateway;}
}
----

Nevertheless, this design, also known as the _Backend for Frontends_ pattern, has a few drawbacks:

* each specific API Gateway is another component to maintain
* a lot of code is duplicated
* each new feature has to be supported in all gateways before all clients can start using it

=== GraphQL in a nutshell

==== What it is

https://graphql.org/[GraphQL] is a query and schema definition language for your backend services.

It allows backend developers to describe the data in a language-agnostic fashion:

[source,graphql]
.GraphQL Schema file
----
type Genre {
  id: ID
  name: String!
}

type Album {
  id: ID
  name: String!
  genre: Genre!
  artist: String!
  reviews: [Review!]
}

type Review {
  name: String!
  rating: Int!
  comment: String
}

type Query {
  albums(genre: ID): [Album!]
}

schema {
  query: Query
}
----

And then frontend developers to request exactly the information they need:

[source,graphql]
.GraphQL query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

Which, given an `id` variable, would result in:

[source,json]
.GraphQL results
----
{
  "album": {
    "name": "Revolver",
    "genre": {
      "name": "Pop"
    },
    "artist": "The Beatles"
  }
}
----

While the https://graphql.github.io/graphql-spec/[GraphQL specification] does not prescribe any transport, in practice it's often used over HTTP and Websockets.

TIP: You will find a GraphQL schema definition and query authoring introduction on https://graphql.org/learn/.

==== How it works

When a GraphQL server runtime starts, it:

. parses the schema file to discover types and fields
. binds each field to data fetching functions

[graphviz,graphql-server-runtime,svg]
.GraphQL server runtime creation
----
strict digraph {
    splines="line";
    schema [label="Types and Fields" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    fetchers [label="Data Fetchers" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    runtime [label="GraphQL Runtime" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    schema -> runtime
    fetchers -> runtime
}
----

Then when a request is received, it:

. validates the query
. invokes each data fetching function needed to produce the result
. sends the result to the client

[graphviz,graphql-query-execution,svg]
.GraphQL query execution phases
----
strict digraph {
    rankdir=LR;
    splines="line";
    validation [label="Validation" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    execution [label="Execution" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    result [label="Result" shape="ellipse" color="#585858" style="filled" fillcolor="#782b90" fontcolor="white"]
    validation -> execution
    execution -> result
}
----

==== API Gateway engine

GraphQL becomes more and more popular, including as a replacement for _RESTful_ or HTTP/JSON APis.

But it particularly shines when building API Gateways.
Why?
Let's consider the product details use case again.

When the desktop client sends a request to the GraphQL runtime, it will ask for product info as well as users' review.
And the runtime will execute the corresponding data fetchers:

[source,graphql]
.Desktop client query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
    reviews {
      name
      comment
      rating
    }
  }
}
----

However, the smartphone client will only ask for the product info:

[source,graphql]
.Smartphone client query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

And the runtime will **NOT** execute the data fetchers for customers' reviews and, obviously, will not send the unnecessary data.

== The MusicStore Application

The _MusicStore_ is an online music shop.
You can browse its catalog by genre, read customer reviews, see the list of tracks.
When logged-in, you may add albums to your cart, manage your cart items or post your own reviews.

Technically, it is comprised of the following components:

* the <<Web Client>>
* the API Gateway which:
** serves the static content
** runs the GraphQL runtime
** authenticates the customers
** records cart items
* the <<Inventory Service>>
* the <<Rating Service>>

[graphviz,musicstore-app,svg]
.The MusicStore application
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Web Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    gateway [label="API Gateway" shape="polygon" color="#782b90" style="rounded" fontcolor="#782b90" fontsize="25" penwidth="2" height=".6"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    gatewaydb [label="MusicStore DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> gateway
    gateway -> gatewaydb
    gateway -> rating
    gateway -> inventory
    {rank = same; gateway; gatewaydb;}
}
----

You will build the API Gateway for this microservices-based application.

NOTE: In a real-world application, the static content would often be served from a separate component.

=== Web Client

A _Single Page Application_ implemented with https://vuejs.org/[Vue.js] and https://www.apollographql.com/docs/react/[Apollo client].

=== Inventory Service

The _Inventory Service_ exposes product data over HTTP in JSON format:

* genres
* albums (name, artist, genre, ...etc)
* tracks

For the sake of simplicity, inventory data is loaded on startup from text files and stored into memory.

=== Rating Service

The _Rating Service_ receives customers' reviews on albums:

* customer name
* rating
* comment

It exposes this data over HTTP in JSON format.
It can also compute an average rating for each album.

Again, for simplicity, reviews are stored only in memory.

== Getting started

=== Prerequisites

==== Java Development Kit

JDK 8 or later must be installed on our machine.
If you don't have it already, you can get one from:

* https://adoptopenjdk.net, or
* https://www.oracle.com/technetwork/java/javase/downloads/index.html

You can use either OpenJDK or Oracle JDK.

==== Maven

Download Apache Maven from https://maven.apache.org/download.cgi.

Extract the archive contents to a directory of your choice and add it to the `PATH`.

==== IDE

It is recommended to use an IDE. It does not matter if it's IntelliJ, Eclipse or Netbeans.

If you don’t have an IDE, follow these instructions to get started with Eclipse:

* browse to the https://www.eclipse.org/downloads/packages/[Eclipse downloads page]
* select the _Eclipse IDE for Java Developers_ package and download it
* extract the archive contents to a directory of your choice
* in the destination directory, execute the Eclipse binary
* create a workspace

==== Postgres database

IMPORTANT: The Postgres database is only required to complete the last step or to run the full solution.
If you cannot get it to work on your machine, you can still complete all the other steps.

If you have Docker running on your machine, you can start the Postgres database in a container:

[source,shell]
.Starting a Postgres Database with Docker
----
docker run -p 5432:5432 -e POSTGRES_USER=musicstore -e POSTGRES_PASSWORD=musicstore -d postgres
----

TIP: Linux and Mac users can simply execute the `run-postgres.sh` script after having imported the code in the next step.

Otherwise:

* download Postgres from https://www.postgresql.org/download/ and follow the instructions for your machine type
* create a `musicstore` database
* create a `musicstore` user with password `musicstore`
* grant the `musicstore` user with the permission to create tables on the the `musicstore` database

As a _superuser_ you could run these queries:

[source,sql]
----
CREATE DATABASE musicstore;
CREATE USER musicstore WITH ENCRYPTED PASSWORD 'musicstore';
GRANT ALL PRIVILEGES ON DATABASE musicstore TO musicstore;
----

=== Importing the code

The project code is hosted on GitHub.
Open a terminal in the directory of your choice and type:

[source,shell]
----
git clone https://github.com/tsegismont/graphql-api-gateway-workshop.git
----

Alternatively, you may download the https://codeload.github.com/tsegismont/graphql-api-gateway-workshop/zip/master[project archive] from GitHub and extract the content.

Inside the project directory, run Maven to build the project:

[source,shell]
----
mvn install
----

Now open the IDE and import the project.

In Eclipse:

* click on _File_ > _Import_
* select _Maven_ > _Existing Maven Projects_
* in _Root Directory_, type the project directory path or select it with the _Browse..._ button
* make sure the root project and all sub-projects checkboxes are ticked and click _Finish_

In IntelliJ:

* click on _File_ > _New_ > _Project from Existing Sources_
* select the `pom.xml` file at the root of the project directory path and click _OK_
* click _Next_ on the following wizard panels and then _Finish_

=== Running backend services

IMPORTANT: Make sure you have built the project beforehand and started the Postgres database.

==== Inventory

Open a terminal at the root of the project directory and type:

[source,shell]
----
cd inventory
./run.sh
----

On Windows, open the file explorer in the `inventory` directory and execute `run.bat`.

If the service starts correctly, you should see a line similar to this on the console:

----
[2019-11-02 21:05:24] [INFO   ] Succeeded in deploying verticle
----

==== Rating

Open a terminal at the root of the project directory and type:

[source,shell]
----
cd rating
./run.sh
----

On Windows, open the file explorer in the `rating` directory and execute `run.bat`.

If the service starts correctly, you should see a line similar to this on the console:

----
[2019-11-02 21:05:24] [INFO   ] Succeeded in deploying verticle
----

== Let's code!

=== Building blocks

==== GraphQL-Java

The https://www.graphql-java.com/[GraphQL-Java] library is the Java implementation of the GraphQL specification.

To configure it, you must provide at least:

* a GraphQL schema, either from a definition file or built programmatically
* data fetchers functions for schema types and fields (_runtime wiring_)

A GraphQL-Java data fetcher must implement the `graphql.schema.DataFetcher` interface.
In practice, it must have a `get` method that takes a `graphql.schema.DataFetchingEnvironment` argument and returns a result:

[source,java]
.DataFetcher interface
----
public interface DataFetcher<T> {
    T get(DataFetchingEnvironment environment) throws Exception;
}
----

The result can be a `CompletionStage` if it is provided asynchronously.

The _environment_ argument gives information about the current position in the graph: source type, arguments, fields to be fetched... etc

The GraphQL-Java runtime job is to execute queries and it does not provide any transport implementation.

==== Eclipse Vert.x

https://vertx.io[Vert.x] is a toolkit to write asynchronous and reactive applications on the JVM.

It implements the reactor pattern and uses _Netty_ for the networking layer.
It is similar to _Node.js_ but it is capable of scaling across CPU cores instead of using a single thread.

Vert.x does not mandate any programming model but the easiest way to get started is to create a _verticle_.

A verticle is an entry-point class with a _start_ method:

[source,java]
.Vert.x verticle
----
public class MyVerticle extends AbstractVerticle {

 // Called when verticle is deployed
 public void start() {
 }

 // Optional - called when verticle is undeployed
 public void stop() {
 }

}
----

The core library provides low-level abstractions to start HTTP servers, work with the filesystem, ...etc.

https://vertx.io/docs/vertx-web-graphql/java/[Vert.x Web GraphQL] integrates the GraphQL-Java library so that queries and results can be sent over HTTP and Websockets.

==== RxJava

Quotinq the https://github.com/ReactiveX/RxJava[RxJava] project website:

[quote, RxJava project]
RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.

When working with asynchronous APIs, the code can quickly become difficult to understand if you need to execute several sequential operations.
It's even worse when composing results of concurrent operations.

This issue is widely known as callback-hell and RxJava provides operators to deal with it.

NOTE: `CompletableFuture` / `CompletionStage` introduced in JDK 8 helps a lot with asynchronous composition.
But RxJava comes with a broader range of operators and is also able to deal with asynchronous data flows.

Let's take a couple of examples:

[source,java]
.Sequential composition: async Postgres query execution and transformation of row results into a Java object
----
public Single<Cart> findCart(String username) {
  return pool.rxPreparedQuery(FIND_CART, Tuple.of(username))
    .flatMapObservable(Observable::fromIterable)
    .map(CartRepository::rowToCartItem)
    .collectInto(new Cart(), Cart::add);
}
----

[source,java]
.Concurrent composition: combining results of async web client requests into a single Java object
----
Single<Album> inventoryData = albumsRepository.findById(id, true);
Single<RatingInfo> ratingData = ratingRepository.findRatingAndReviewsByAlbum(id);
return inventoryData.zipWith(ratingData, (a, r) -> {
  a.setRating(r.getRating());
  a.setReviews(r.getReviews());
  return a;
});
----

By default, Vert.x uses a callback style but it also has an https://vertx.io/docs/vertx-rx/java2/[Rxified API].

=== Steps

This lab is divided into several steps incrementally building the API Gateway for the _MusicStore_ application.

Each step can be run separately.
To do so, open a terminal in the step directory and type:

[source,shell]
----
mvn vertx:run
----

Then start coding.
The step projects all use the _Vert.x Maven plugin_ which automatically redeploys the code when a file changes.

On Windows, open the file explorer in the step directory and execute `run.bat`.

The files to edit are either in the `src/main/java` or the `src/main/resources` directory.

Each step has its solution in the `src/solution` directory.
You may run it with:

[source,shell]
----
mvn clean package -Psolution
java -jar target/step-0.jar -Dvertxweb.environment=dev
----

On Windows, open the file explorer in the step directory and execute `run-solution.bat`.

IMPORTANT: To avoid port conflicts, don't forget to close the server before you start working on the next step.

A complete solution can be found in the `gateway` directory.
