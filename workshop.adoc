= Implementing the API Gateway pattern with GraphQL
Vladimir Dejanovic <https://twitter.com/vladimird_42[@vladimird_42]>; Thomas Segismont <https://twitter.com/tsegismont[@tsegismont]>
:toc: left
:toclevels: 3
:source-highlighter: rouge

== Introduction

=== Microservices architecture

In a https://microservices.io/patterns/microservices.html[microservices architecture], several loosely coupled, independently deployable services comprise a large software application.

This type of design can provide quite a few benefits, including:

* ability to release more often and more reliably
* codebases easier to reason about
* independence to a particular technology

For example, an online store application could be composed of, among others, an inventory and a rating service:

[graphviz, microservices-architecture, svg]
.Online store application, microservices architecture
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> inventory
    client -> rating
    inventory -> inventorydb
    rating -> ratingdb
}
----

=== The API Gateway pattern

The client side of the application may have to contact several services to display a single screen or page.
For instance, to display a product details page, it needs product info from the inventory service and customer reviews from the rating service.

But each network communication comes with a cost.
This applies to desktop browsers with DSL or fiber links, but the impact is particularly significant on mobile networks.

This is one important reason why the _API Gateway_ pattern has emerged.
In practice, the client communicates with a single service, the gateway, which communicates with the backend services:

[graphviz, api-gateway-pattern, svg]
.API Gateway pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    client [label="Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    gateway [label="API Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    gatewaydb [label="Gateway DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    client -> gateway
    gateway -> gatewaydb
    gateway -> rating
    gateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = same; gateway; gatewaydb;}
}
----

[NOTE]
====
The API Gateway does not eliminate the coordination required to make sense of the backend data.
In fact, it adds a new network hop in the the sequence of service calls.

But it moves most of the interactions inside the datacenter, where network latencies are considerably better.
====

Very often, the API Gateway implements cross-cutting concerns like security.
For example, it could generate a token after authenticating the client and communicate it to the backend services as a proof of identity.

Also, it may provide its own features, if they are only relevant to the frontend.
An e-commerce application, for instance, could manage customers' shopping carts at the API Gateway level.

=== Serving many clients

A lot of applications nowadays must be available from a wide range of clients: browsers, smartphones, tablets, wearables... etc.
These clients all have different capabilities in terms of display and networking.

Let's consider the product details use case.
For a desktop user, it makes sense to show:

* the product info (inventory service)
* the average rating (rating service)
* users' reviews (rating service)

However, in a smartphone app the reviews would probably be accessible in a separate view because of the screen size and shape.

But if the mobile developer uses the same endpoint as the web developer, the API Gateway wastes:

* time (_latency_) waiting for rating service responses, and
* bandwith sending a lot of unnecessary data.

To overcome this problem, it is possible to create a backend specific to each type of frontend.

[graphviz,backend-for-frontends,svg]
.Backend for Frontends pattern
----
strict digraph {
    rankdir=LR;
    splines="line";
    webclient [label="Web Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    mobileclient [label="Mobile Client" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    webgateway [label="Web Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    mobilegateway [label="Mobile Gateway" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventory [label="Inventory service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    rating [label="Rating service" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    inventorydb [label="Inventory DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    ratingdb [label="Rating DB"  shape=cylinder color="#585858" style="filled" fillcolor="#008bb9" fontcolor="white"]
    webclient -> webgateway
    mobileclient -> mobilegateway
    webgateway -> rating
    webgateway -> inventory
    mobilegateway -> rating
    mobilegateway -> inventory
    inventory -> inventorydb
    rating -> ratingdb
    {rank = clients; mobileclient; webclient;}
    {rank = gateways; mobilegateway; webgateway;}
}
----

Nevertheless, this design, also known as the _Backend for Frontends_ pattern, has a few drawbacks:

* each specific API Gateway is another component to maintain
* a lot of code is duplicated
* each new feature has to be supported in all gateways before all clients can start using it

=== GraphQL in a nutshell

==== What it is

https://graphql.org/[GraphQL] is a query and schema definition language for your backend services.

It allows backend developers to describe the data in a language-agnostic fashion:

[source,graphql]
.GraphQL Schema file
----
type Genre {
  id: ID
  name: String!
}

type Album {
  id: ID
  name: String!
  genre: Genre!
  artist: String!
  reviews: [Review!]
}

type Review {
  name: String!
  rating: Int!
  comment: String
}

type Query {
  albums(genre: ID): [Album!]
}

schema {
  query: Query
}
----

And then frontend developers to request exactly the information they need:

[source,graphql]
.GraphQL query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

Which, given an `id` variable, would result in:

[source,json]
.GraphQL results
----
{
  "album": {
    "name": "Revolver",
    "genre": {
      "name": "Pop"
    },
    "artist": "The Beatles"
  }
}
----

While the https://graphql.github.io/graphql-spec/[GraphQL specification] does not prescribe any transport, in practice it's often used over HTTP and Websockets.

TIP: You will find a GraphQL schema definition and query authoring introduction on https://graphql.org/learn/.

==== How it works

When a GraphQL server runtime starts, it:

. parses the schema file to discover types and fields
. binds each field to data fetching functions

[graphviz,graphql-server-runtime,svg]
.GraphQL server runtime creation
----
strict digraph {
    splines="line";
    schema [label="Types and Fields" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    fetchers [label="Data Fetchers" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    runtime [label="GraphQL Runtime" shape="polygon" color="#585858" style="rounded,filled" fillcolor="#782b90" fontcolor="white"]
    schema -> runtime
    fetchers -> runtime
}
----

Then when a request is received, it:

. validates the query
. invokes each data fetching function needed to produce the result
. sends the result to the client

[graphviz,graphql-query-execution,svg]
.GraphQL query execution phases
----
strict digraph {
    rankdir=LR;
    splines="line";
    validation [label="Validation" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    execution [label="Execution" shape="ellipse" color="#585858" style="filled" fillcolor="#848484" fontcolor="white"]
    result [label="Result" shape="ellipse" color="#585858" style="filled" fillcolor="#782b90" fontcolor="white"]
    validation -> execution
    execution -> result
}
----

==== API Gateway engine

GraphQL becomes more and more popular, including as a replacement for _RESTful_ or HTTP/JSON APis.

But it particularly shines when building API Gateways.
Why?
Let's consider the product details use case again.

When the desktop client sends a request to the GraphQL runtime, it will ask for product info as well as users' review.
And the runtime will execute the corresponding data fetchers:

[source,graphql]
.Desktop client query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
    reviews {
      name
      comment
      rating
    }
  }
}
----

However, the smartphone client will only ask for the product info:

[source,graphql]
.Smartphone client query
----
query ($id: ID!) {
  album(id: $id) {
    id
    name
    genre {
      name
    }
    artist
  }
}
----

And the runtime will **NOT** execute the data fetchers for users' reviews and, obviously, will not send the unnecessary data.

== What you will build

You will build a gateway for a music store microservices-based application.

=== The MusicStore Application

== Getting started

=== Prerequisites

==== Java Development Kit

JDK 8 or later must be installed on our machine.
If you don't have it already, you can get one from:

* https://adoptopenjdk.net, or
* https://www.oracle.com/technetwork/java/javase/downloads/index.html

You can use either OpenJDK or Oracle JDK.

==== Maven

Download Apache Maven from https://maven.apache.org/download.cgi.

Extract the archive contents to a directory of your choice and add it to the `PATH`.

==== IDE

It is recommended to use an IDE. It does not matter if it's IntelliJ, Eclipse or Netbeans.

If you don’t have an IDE, follow these instructions to get started with Eclipse:

* browse to the https://www.eclipse.org/downloads/packages/[Eclipse downloads page]
* select the _Eclipse IDE for Java Developers_ package and download it
* extract the archive contents to a directory of your choice
* in the destination directory, execute the Eclipse binary
* create a workspace

==== Postgres database

If you have Docker running on your machine, you can start the Postgres database in a container:

[source,shell]
.Starting a Postgres Database with Docker
----
docker run -p 5432:5432 -e POSTGRES_USER=musicstore -e POSTGRES_PASSWORD=musicstore -d postgres
----

TIP: Linux and Mac users can simply execute the `run-postgres.sh` script after having imported the code in the next step.

Otherwise, browse to https://www.postgresql.org/download/ and follow the instructions for your machine type.

=== Getting the code

The project code is hosted on GitHub.
Open a terminal in the directory of your choice and type:

[source,shell]
----
git clone https://github.com/tsegismont/graphql-api-gateway-workshop.git
----

Alternatively, you may download the https://codeload.github.com/tsegismont/graphql-api-gateway-workshop/zip/master[project archive] from GitHub and extract the content.

Inside the project directory, run Maven to build the project:

[source,shell]
----
mvn install
----

Now open the IDE and import the project.

In Eclipse:

* click on _File_ > _Import_
* select _Maven_ > _Existing Maven Projects_
* in _Root Directory_, type the project directory path or select it with the _Browse..._ button
* make sure the root project and all sub-projects checkboxes are ticked and click _Finish_

In IntelliJ:

* click on _File_ > _New_ > _Project from Existing Sources_
* select the `pom.xml` file at the root of the project directory path and click _OK_
* click _Next_ on the following wizard panels and then _Finish_
